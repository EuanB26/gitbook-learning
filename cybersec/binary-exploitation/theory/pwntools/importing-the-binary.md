# Importing the Binary

### ELF class

These two classes are what is going to be used a lot in your exploits.

We can use the `ELF` class when dealing with a Linux executable \(ELF: Executable and Linkable Format\). Using the ELF class, we can pull out ROP gadgets from the binary, function addresses, writable pages etc. To use this, we have to specify a file, in this case I'm specifying the filename `program` in our current directory.

{% tabs %}
{% tab title="ELF" %}
```python
#Usage:
ELF(path, checksec=True)
```

```python
#Example:
e = ELF("./program")
```
{% endtab %}
{% endtabs %}

### Process class

When we want to interact with the binary when it's in runtime, we can use the `process` class. Processes can be made, either by themselves, or being linked to an ELF file

{% tabs %}
{% tab title="Process" %}
```python
#Usage:
process(argv=None, shell=False, executable=None, 
cwd=None,env=None, stdin=-1, 
stdout=<pwnlib.tubes.process.PTY object>,
stderr=-2, close_fds=True, 
preexec_fn=<function <lambda>>, raw=True,
aslr=None, setuid=None, where='local',
display=None, alarm=None, *args, **kwargs)
```

```python
#Example:
p = process("./program")
```
{% endtab %}
{% endtabs %}

Parameters:



* **argv** \(_list_\) – List of arguments to pass to the spawned process.
* **shell** \(bool\) – Set to True to interpret argv as a string to pass to the shell for interpretation instead of as argv.
* **executable** \(str\) – Path to the binary to execute. If `None`, uses `argv[0]`. Cannot be used with `shell`.
* **cwd** \(str\) – Working directory. Uses the current working directory by default.
* **env** \(dict\) – Environment variables. By default, inherits from Python’s environment.
* **stdin** \(int\) – File object or file descriptor number to use for `stdin`. By default, a pipe is used. A pty can be used instead by setting this to `PTY`. This will cause programs to behave in an interactive manner \(e.g.., `python` will show a `>>>` prompt\). If the application reads from `/dev/tty` directly, use a pty.
* **stdout** \(int\) – File object or file descriptor number to use for `stdout`. By default, a pty is used so that any stdout buffering by libc routines is disabled. May also be `PIPE` to use a normal pipe.
* **stderr** \(int\) – File object or file descriptor number to use for `stderr`. By default, `STDOUT` is used. May also be `PIPE` to use a separate pipe, although the [`pwnlib.tubes.tube.tube`](https://docs.pwntools.com/en/stable/tubes.html#pwnlib.tubes.tube.tube) wrapper will not be able to read this data.
* **close\_fds** \(bool\) – Close all open file descriptors except stdin, stdout, stderr. By default, `True` is used.
* **preexec\_fn** \(_callable_\) – Callable to invoke immediately before calling `execve`.
* **raw** \(bool\) – Set the created pty to raw mode \(i.e. disable echo and control characters\). `True` by default. If no pty is created, this has no effect.
* **aslr** \(bool\) –

  If set to `False`, disable ASLR via `personality` \(`setarch -R`\) and `setrlimit` \(`ulimit -s unlimited`\).

  This disables ASLR for the target process. However, the `setarch` changes are lost if a `setuid` binary is executed.

  The default value is inherited from `context.aslr`. See `setuid` below for additional options and information.

* **setuid** \(bool\) –

  Used to control setuid status of the target binary, and the corresponding actions taken.

  By default, this value is `None`, so no assumptions are made.

  If `True`, treat the target binary as `setuid`. This modifies the mechanisms used to disable ASLR on the process if `aslr=False`. This is useful for debugging locally, when the exploit is a `setuid` binary.

  If `False`, prevent `setuid` bits from taking effect on the target binary. This is only supported on Linux, with kernels v3.5 or greater.

* **where** \(str\) – Where the process is running, used for logging purposes.
* **display** \(list\) – List of arguments to display, instead of the main executable name.
* **alarm** \(int\) – Set a SIGALRM alarm timeout on the process.

### Working remotely

So, we've managed to exploit our binary through some means. But how do we now move to the remote machine? Say for example, we had the binary hosted on `example.ourctf.com:31337`, how could we access it?

Pwntools has a nice feature called `remote` which allows us to access a binary when it's on "remote", or on the target machine

{% tabs %}
{% tab title="Remote" %}
```python
#Usage:
remote(host, port, fam='any', typ='tcp',
 ssl=False, sock=None, ssl_args=None, *args, 
 **kwargs)
```

```python
#Example:
r = remote('127.0.0.1', 31337)
```
{% endtab %}
{% endtabs %}

Parameters:

* **host** \(str\) – The host to connect to.
* **port** \(int\) – The port to connect to.
* **fam** – The string “any”, “ipv4” or “ipv6” or an integer to pass to [`socket.getaddrinfo()`](https://docs.python.org/2.7/library/socket.html#socket.getaddrinfo).
* **typ** – The string “tcp” or “udp” or an integer to pass to [`socket.getaddrinfo()`](https://docs.python.org/2.7/library/socket.html#socket.getaddrinfo).
* **timeout** – A positive number, None or the string “default”.
* **ssl** \(bool\) – Wrap the socket with SSL
* **sock** \(_socket.socket_\) – Socket to inherit, rather than connecting
* **ssl\_args** \(dict\) – Pass ssl.wrap\_socket named arguments in a dictionary.

### SSH

We can also connect via `ssh` if needed:

{% tabs %}
{% tab title="SSH" %}
```python
#Usage:
ssh(user=None, host=None, port=22, password=None,
key=None, keyfile=None, proxy_command=None,
proxy_sock=None, level=None, cache=True,
ssh_agent=False, *a, **kw)
```

```python
#Example:
conn = ssh(host='example.ourctf.com', 
user='EuanB26', password='P4$$w0rd')
```
{% endtab %}
{% endtabs %}

Parameters:

* **user** \(str\) – The username to log in with
* **host** \(str\) – The hostname to connect to
* **port** \(int\) – The port to connect to
* **password** \(str\) – Try to authenticate using this password
* **key** \(str\) – Try to authenticate using this private key. The string should be the actual private key.
* **keyfile** \(str\) – Try to authenticate using this private key. The string should be a filename.
* **proxy\_command** \(str\) – Use this as a proxy command. It has approximately the same semantics as ProxyCommand from ssh\(1\).
* **proxy\_sock** \(str\) – Use this socket instead of connecting to the host.
* **timeout** – Timeout, in seconds
* **level** – Log level
* **cache** – Cache downloaded files \(by hash/size/timestamp\)
* **ssh\_agent** – If `True`, enable usage of keys via ssh-agent

