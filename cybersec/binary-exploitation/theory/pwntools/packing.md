# Packing and Context

When we looked at endianness, we looked at the difference between big endian and little endian. If a binary is compiled using little endian, that means that we have to send data to it in little endian format. Say that we had an address that we wanted to send as part of our exploit, `0xbadc0fee`, we would have to send it in little endian format, so either as `0xee0fcdba`, or more commonly as `\xee\x0f\xcd\xba`, with the `\x`representing that it's a hex integer.

### Packing

So, to pack integers, pwntools offers the function  `p8()`,`p16()`,`p32()` and `p64()` for packing integers. They all contain the same usage and arguments, the only difference being for how you want to pack them - through 8 bit, 16 bit, 32 bit or 64 bits.

{% tabs %}
{% tab title="p8" %}
```python
#Usage:
p8(number, sign, endian, ...)
```

```python
#Example:
payload = p8(0xde)

#Output:
b'\xde'
```
{% endtab %}

{% tab title="p16" %}
```python
#Usage:
p16(number, sign, endian, ...)
```

```python
#Example:
payload = p16(0xdead)

#Output:
b'\xad\xde'
```
{% endtab %}

{% tab title="p32" %}
```python
#Usage:
p32(number, sign, endian, ...)
```

```python
#Example:
payload = p32(0xdeadb33f)

#Output:
b'\xef\xbe\xad\xde'
```
{% endtab %}

{% tab title="p64" %}
```python
#Usage
p64(number, sign, endian, ...)
```

```python
#Example:
payload = p64(0xdeadbeefc0ffee00)

#Output:
b'\x00\xee\xff\xc0\xef\xbe\xad\xde'
```
{% endtab %}
{% endtabs %}

Parameters:

* **number** \(int\) – Number to convert
* **endianness** \(str\) – Endianness of the converted integer \(“little”/”big”\)
* **sign** \(str\) – Signedness of the converted integer \(“unsigned”/”signed”\)
* **kwargs** \(dict\) – Arguments passed to context.local\(\), such as `endian` or `signed`.

### Unpacking

So, how do we go from little endian to big endian again? We can unpack! Again, pwntools offers this option, which instead of the `p`, it has a `u`

{% tabs %}
{% tab title="u8" %}
```python
#Usage:
u8(number, sign, endian, ...) 
```

```python
#Example
data = hex(u8('\xde'))

#Output:
0xde
```
{% endtab %}

{% tab title="u16" %}
```python
#Usage:
u16(number, sign, endian, ...)
```

```python
#Example:
data = hex(u16('\xad\xde'))

#Output:
0xdead
```
{% endtab %}

{% tab title="u32" %}
```python
#Usage:
u32(number, sign, endian, ...) 
```

```python
#Example:
data = hex(u32('\xef\xbe\xad\xde'))

#Output:
0xdeadbeef
```
{% endtab %}

{% tab title="u64" %}
```python
#Usage
u64(number, sign, endian, ...) 
```

```python
#Example:
data = hex(u64('\x00\xee\xff\xc0\xef\xbe\xad\xde'))

#Output:
0xdeadbeefc0ffee00
```
{% endtab %}
{% endtabs %}

Parameters:

* **data** \(str\) – String to convert
* **endianness** \(str\) – Endianness of the converted integer \(“little”/”big”\)
* **sign** \(str\) – Signedness of the converted integer \(“unsigned”/”signed”\)
* **kwargs** \(dict\) – Arguments passed to context.local\(\), such as `endian` or `signed`

### Context

When we're packing our data, we don't want to have to keep on repeating ourselves. So the `context` class allows us to set variables, keeping the repetition out. For example, we could set the version of OS that we're using, or whether we want little or big endian

{% tabs %}
{% tab title="Context" %}
```python
#Endian
context.endian = 'le'
#{'be': 'big', 
# 'big': 'big', 
# 'eb': 'big', 
# 'el': 'little', 
# 'le': 'little',
# 'little': 'little'}
```

```python
#ASLR
context.aslr = False
# True or False
```

```python
#OS
context.os = 'linux' 
#['android', 'cgc', 'freebsd', 'linux', 'windows']
```

```python
#Timeout for recv
context.timeout = 5
#Given in seconds
```
{% endtab %}
{% endtabs %}

