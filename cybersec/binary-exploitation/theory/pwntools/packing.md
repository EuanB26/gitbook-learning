# Packing

When we looked at endianness, we looked at the difference between big endian and little endian. If a binary is compiled using little endian, that means that we have to send data to it in little endian format. Say that we had an address that we wanted to send as part of our exploit, `0xbadc0fee`, we would have to send it in little endian format, so either as `0xee0fcdba`, or more commonly as `\xee\x0f\xcd\xba`, with the `\x`representing that it's a hex integer.

### Packing

So, to pack integers, pwntools offers the function  `p8()`,`p16()`,`p32()` and `p64()` for packing integers. They all contain the same usage and arguments, the only difference being for how you want to pack them - through 8 bit, 16 bit, 32 bit or 64 bits.

{% tabs %}
{% tab title="p8" %}
```python
#Usage:
p8(number, sign, endian, ...)
```

```python
#Example:
payload = p8(0xdeadb33f)
```
{% endtab %}

{% tab title="p16" %}
```python
#Usage:
p16(number, sign, endian, ...)
```

```python
#Example:
payload = p16(0xdeadb33f)
```
{% endtab %}

{% tab title="p32" %}
```python
#Usage:
p32(number, sign, endian, ...)
```

```python
#Example:
payload = p32(0xdeadb33f)
```
{% endtab %}

{% tab title="p64" %}
```python
#Usage
p64(number, sign, endian, ...)
```

```python
#Example:
payload = p64(0xdeadb33f)
```
{% endtab %}
{% endtabs %}

Parameters:

* **number** \(int\) – Number to convert
* **endianness** \(str\) – Endianness of the converted integer \(“little”/”big”\)
* **sign** \(str\) – Signedness of the converted integer \(“unsigned”/”signed”\)
* **kwargs** \(dict\) – Arguments passed to context.local\(\), such as `endian` or `signed`.

