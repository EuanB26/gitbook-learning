# \(SIG\)ROP

Let's first talk about what ROP is

## ROP

Return Orientated Programming \(ROP\) is essentially chaining together parts of the program, in assembly, to allow us to gain a shell from the binary, or do other malicious things.

The reason that we use ROP is because most binaries, when out in the wild or even in CTFs, don't have a "win" function. Therefore, we have to create our own.

When we've managed to pwn the binary and are wondering where to go next, we need to call `execve` \(or it's family, that is `execl`,`execle`, `execlp`,`execlpe`,`execv`, `execve`, `execvp`, more can be at [https://www.geeksforgeeks.org/exec-family-of-functions-in-c/](https://www.geeksforgeeks.org/exec-family-of-functions-in-c/)\) or `system`. But we're going to need some arguments ... one common one is the string `/bin/sh` as that's what our terminals run off of - using the programming language `bash` which is spawn in via `/bin/sh`.

### x86

Sow how would we provide our arguments to the function? Well the function will expect it to be called via this:

* &lt;function&gt;
* &lt;exit function / junk&gt;
* &lt;argument&gt;

This is just how the binary expects the arguments to be, with the stack layout being something along the lines of \(once the function has been called\):

```java
| return address |
|    arguments   |
```

This way, when `main()` returns, it will call `system` PLT entry, and the stack will appear as though `system` has been called normally.

_Note: we don't care where our return address points to, as we have our shell. It's there if we need to cleanly exit the program - where do we jump to if we fail._

### x86-64

Here, we have to work a bit harder - as we recall from the [System V Calling Conventions](../../theory/system-v-calling-conventions.md) , 64 bit machines take their arguments from the registers. When we pwn the binary, we take control of `rip`. But now, we also need to take control of `rdi`.

In this case, we need to take small parts of the binary, known as `gadgets`. These usually include a `pop` a value, or a couple, into register\(s\), and then a `ret` instruction. This allows us to chain together multiple commands to get our malicious code to execute, essentially setting up a fake stack.

```java
0x401e49    pop rdi; ret
0x401e50    pop rsi; pop r9; xor rax; ret 
```

## SIGROP

This is essentially calling a `sigcontext` structure



[https://arxiv.org/abs/1609.02667](https://arxiv.org/abs/1609.02667)



