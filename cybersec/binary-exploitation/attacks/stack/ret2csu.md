# Ret2dlresolve

As we saw in [Static vs Dynamic Linking](../../theory/static-vs-dynamic-linking.md) , dynamically linked binaries are linked with a libc file when they're executed. So when a program has ASLR turned on, it won't know the location of where the functions are inside the libc. It has to go through some checks to see where everything is. We can target this functionality. 

## Background knowledge

The `.dynamic` section of a binary contains multiple information used by `ld.so` to resolve the symbols at runtime.

```c
$ readelf -d ./binary
Dynamic section at offset 0xec8 contains 27 entries:
  Tag        Type                         Name/Value
 0x00000001 (NEEDED)                     Shared library: [libc.so.6]
 0x0000000c (INIT)                       0x43c
 0x0000000d (FINI)                       0x744
 0x00000019 (INIT_ARRAY)                 0x1ec0
 0x0000001b (INIT_ARRAYSZ)               4 (bytes)
 0x0000001a (FINI_ARRAY)                 0x1ec4
 0x0000001c (FINI_ARRAYSZ)               4 (bytes)
 0x6ffffef5 (GNU_HASH)                   0x1ac
 0x00000005 (STRTAB)                     0x2ac
 0x00000006 (SYMTAB)                     0x1cc
 0x0000000a (STRSZ)                      195 (bytes)
 0x0000000b (SYMENT)                     16 (bytes)
 0x00000015 (DEBUG)                      0x0
 0x00000003 (PLTGOT)                     0x1fc0
 0x00000002 (PLTRELSZ)                   48 (bytes)
 0x00000014 (PLTREL)                     REL
 0x00000017 (JMPREL)                     0x40c
 0x00000011 (REL)                        0x3bc
 0x00000012 (RELSZ)                      80 (bytes)
 0x00000013 (RELENT)                     8 (bytes)
 0x0000001e (FLAGS)                      BIND_NOW
 0x6ffffffb (FLAGS_1)                    Flags: NOW PIE
 0x6ffffffe (VERNEED)                    0x38c
 0x6fffffff (VERNEEDNUM)                 1
 0x6ffffff0 (VERSYM)                     0x370
 0x6ffffffa (RELCOUNT)                   4
 0x00000000 (NULL)                       0x0
```

We will focus on `SYMTAB`, `STRTAB`, `JMPREL`.

### JMPREL

The `JMPREL` segment \(corresponding the `rel.plt`\) stores a table called _Relocation table_. Each entry maps to a symbol.

```c
$ readelf -r ./binary

Relocation section '.rel.dyn' at offset 0x3bc contains 10 entries:
 Offset     Info    Type            Sym.Value  Sym. Name
00001ec0  00000008 R_386_RELATIVE   
00001ec4  00000008 R_386_RELATIVE   
00001ff8  00000008 R_386_RELATIVE   
00002004  00000008 R_386_RELATIVE   
00001fe4  00000106 R_386_GLOB_DAT    00000000   _ITM_deregisterTMClone
00001fe8  00000506 R_386_GLOB_DAT    00000000   __cxa_finalize@GLIBC_2.1.3
00001fec  00000706 R_386_GLOB_DAT    00000000   __gmon_start__
00001ff0  00000906 R_386_GLOB_DAT    00000000   stdin@GLIBC_2.0
00001ff4  00000b06 R_386_GLOB_DAT    00000000   stdout@GLIBC_2.0
00001ffc  00000c06 R_386_GLOB_DAT    00000000   _ITM_registerTMCloneTa

Relocation section '.rel.plt' at offset 0x40c contains 6 entries:
 Offset     Info    Type            Sym.Value  Sym. Name
00001fcc  00000207 R_386_JUMP_SLOT   00000000   printf@GLIBC_2.0
00001fd0  00000307 R_386_JUMP_SLOT   00000000   fflush@GLIBC_2.0
00001fd4  00000407 R_386_JUMP_SLOT   00000000   fgets@GLIBC_2.0
00001fd8  00000607 R_386_JUMP_SLOT   00000000   puts@GLIBC_2.0
00001fdc  00000807 R_386_JUMP_SLOT   00000000   __libc_start_main@GLIBC_2.0
00001fe0  00000a07 R_386_JUMP_SLOT   00000000   memset@GLIBC_2.0
```

The type of these entries is `ELF\_REL`, which is defined as followed. The size of one entry is 8 bytes

```c
typedef uint32_t Elf32_Addr ; 
typedef uint32_t Elf32_Word ; 
typedef struct 
{
   Elf32_Addr r_offset ; /* Address */ 
   Elf32_Word r_info ; /* Relocation type and symbol index */ 
} Elf32_Rel ; 
#define ELF32_R_SYM(val) ((val) >> 8) 
#define ELF32_R_TYPE(val) ((val) & 0xff)
```

Let's take a look at the first entry in our `rel.plt` table.

```c
Offset     Info    Type            Sym.Value  Sym. Name
00001fcc  00000207 R_386_JUMP_SLOT   00000000   printf@GLIBC_2.0
```

* The _Offset_ is the address of the GOT entry in our table, in this case `0x00001fcc`.
* The _Info_ stores additional metadata such as `ELF_R_SYM` or `ELF_R_TYPE`.
* The _Sym. Name_ gives us the name of our symbol, in this case `printf@GLIBC_2.0`.
* According to the MACROS in the `#define` section

  * `ELF32_R_SYM(r_info) == 1`
  * `ELF32_R_TYPE(r_info) == 7 (R_386_JUMP_SLOT)`
  * `R_SYM = 1`

  \`\`

### STRTAB

STRTAB is simply a table which contains the strings for symbols names \(look at the value of STRTAB when we did looked at the `.dynamic` section\).

```c
gdb-peda$ x/10s 0x2ac
0x2ac:	""
0x2ad:	"libc.so.6"
0x2b7:	"_IO_stdin_used"
0x2c6:	"fflush"
0x2cd:	"puts"
0x2d2:	"stdin"
0x2d8:	"printf"
0x2df:	"fgets"
0x2e5:	"memset"
0x2ec:	"stdout"
```

### SYMTAB

This table holds relevant symbols information. Each entry is a `ELF32_Sym` structure and is 16 bytes

```c
typedef struct 
{ 
   Elf32_Word st_name ; /* Symbol name (string tbl index) */
   Elf32_Addr st_value ; /* Symbol value */ 
   Elf32_Word st_size ; /* Symbol size */ 
   unsigned char st_info ; /* Symbol type and binding */ 
   unsigned char st_other ; /* Symbol visibility under glibc>=2.2 */ 
   Elf32_Section st_shndx ; /* Section index */ 
} Elf32_Sym ;
```

The firtst field,`st_name`, gives the offset in _STRTAB_ where the name of the symbol begins. The other fields aren't used in the exploit, so they won't be covered here. However, they can be found heree: [https://www.cs.princeton.edu/courses/archive/fall01/cs217/assignment5/2.1.html](https://www.cs.princeton.edu/courses/archive/fall01/cs217/assignment5/2.1.html)

The `ELF_R_SYM(r_info) == 1` variable \(from JMPREL table\) gives the index of the `ELF32_SYM` in SYMTAB for the specified symbol, in this case it's set to 1

```c
// (SYMTAB + index*sizeof(entry)) where index = ELF32_R_SYM(r_info)
gdb-peda$ x/4w 0x1cc + 1*16
0x1dc:	U"~"
0x1e4:	U""
0x1e8:	U" ,"
0x1f4:	U""

// (STRTAB + st_name)
gdb-peda$ x/s 0x2ac + 0x1dc
0x488 <fflush@plt+8>:	""
gdb-peda$ x/s 0x2ac + 0x1e4
0x490 <fgets@plt>:	"\377\243\024"
gdb-peda$ x/s 0x2ac + 0x1e8
0x494 <fgets@plt+4>:	""
gdb-peda$ x/s 0x2ac + 0x1f4
0x4a0 <puts@plt>:	"\377\243\030"
```

Adding the first 4 bytes from elf32\_sym to STRTAB gives the address of the symbol name.

## \_dl\_runtime\_resolve



